<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiaxing的个人主页</title>
  
  
  <link href="https://wilsssssssson.github.io/PersonalPage/atom.xml" rel="self"/>
  
  <link href="https://wilsssssssson.github.io/PersonalPage/"/>
  <updated>2025-02-23T08:15:47.917Z</updated>
  <id>https://wilsssssssson.github.io/PersonalPage/</id>
  
  <author>
    <name>Jiaxing Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨域解决方法</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2025/02/23/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2025/02/23/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2025-02-23T07:27:27.000Z</published>
    <updated>2025-02-23T08:15:47.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域解决方法"><a href="#浏览器跨域解决方法" class="headerlink" title="浏览器跨域解决方法"></a>浏览器跨域解决方法</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1">跨域概念解析</a></li><li><a href="#2">JSONP解决方案</a></li><li><a href="#3">document.domain + iframe方案</a></li><li><a href="#4">location.hash + iframe方案</a></li><li><a href="#5">window.name + iframe方案</a></li><li><a href="#6">postMessage API方案</a></li><li><a href="#7">CORS跨域方案</a></li><li><a href="#8">WebSocket协议方案</a></li></ol><h2 id="1">一、跨域概念解析</h2><p>当前浏览器的内容访问要求同源，所谓同源即是<code>url的方案（协议）</code>，<code>主机（域名）</code>，<code>和端定义</code>，<br>只有当方案，主机和端口都匹配时，两个对象具有相同的起源<br>同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介</p><h2 id="2">二、JSONP解决方案</h2><p>在html标签中很多带src属性的标签都可以跨域请求内容，比如我们熟悉的img图片标签。同理，script标签也可以，<br>通过<code>&lt;script&gt;</code>标签来实现跨域数据请求的方法。其工作原理主要依赖于浏览器对<code>&lt;script&gt;</code>标签的src属性没有同源策略限制这一特性。下面详细解释其实现跨域的步骤：</p><ol><li><p><strong>创建回调函数</strong>：在你的网页中定义一个全局函数，这个函数将被用来处理从其他域返回的数据。</p></li><li><p><strong>构造<code>&lt;script&gt;</code>标签</strong>：动态地创建一个<code>&lt;script&gt;</code>元素，并设置它的src属性为目标服务器的URL。在这个URL中，你需要指定一个参数来告诉服务器你的回调函数名称。</p></li><li><p><strong>服务器响应</strong>：当目标服务器收到请求后，它会构建一段JavaScript代码作为响应。这段代码调用你在第一步中定义的回调函数，并将需要的数据作为参数传递给这个函数。</p></li><li><p><strong>执行脚本</strong>：浏览器接收到服务器的响应后，会执行这段JavaScript代码，从而触发你之前定义的回调函数，完成数据的获取和处理。</p></li></ol><p>例如，假设你想从<code>example.com</code>获取数据，并且已经定义了一个名为<code>handleResponse</code>的回调函数，那么你可以创建一个<code>&lt;script&gt;</code>标签，其src属性为<code>http://example.com/data?callback=handleResponse</code>。服务器应该返回类似<code>handleResponse(&#123;...&#125;)</code>的JavaScript代码，其中<code>&#123;...&#125;</code>是实际的数据。</p><p>需要注意的是，由于JSONP的实现方式，它只能支持GET请求，而且如果服务器不正确地处理回调参数，可能会引发安全问题，如XSS攻击。因此，在使用JSONP时需要格外小心。随着CORS（跨源资源共享）机制的普及，JSONP逐渐被更为安全的CORS替代。</p><h2 id="3">三、document.domain + iframe方案</h2><p>使用 <code>document.domain</code> 和 <code>&lt;iframe&gt;</code> 实现跨域通信是一种传统的方法，主要用于主域名相同但子域名不同的情况下。例如，父页面位于 <code>a.example.com</code>，而子页面位于 <code>b.example.com</code>。通过设置 <code>document.domain</code>，可以让这两个不同子域名的页面认为它们属于同一个源（即相同的主域名），从而允许它们之间进行直接的JavaScript交互。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p><strong>设置 <code>document.domain</code></strong>：</p><ul><li>在父页面和子页面中都显式地设置 <code>document.domain</code> 为相同的主域名。比如，如果两个页面分别位于 <code>a.example.com</code> 和 <code>b.example.com</code>，则在每个页面中添加以下代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;example.com&quot;</span>;</span><br></pre></td></tr></table></figure>这样做之后，两个页面就会被视为来自同一源。</li></ul></li><li><p><strong>建立 iframe 嵌套</strong>：</p><ul><li>在父页面中嵌入一个指向子页面的 <code>&lt;iframe&gt;</code> 标签：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://b.example.com/page.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>实现通信</strong>：</p><ul><li>在父页面中，可以通过获取 iframe 的 contentWindow 对象来访问子页面中的 JavaScript 变量或调用其函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> iframeWindow = iframe.<span class="property">contentWindow</span>;</span><br><span class="line"><span class="comment">// 调用子页面中的函数</span></span><br><span class="line">iframeWindow.<span class="title function_">someFunction</span>();</span><br></pre></td></tr></table></figure></li><li>同样，在子页面中也可以访问父页面的 JavaScript 变量或调用其函数：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">someParentFunction</span>();</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>这种方法仅适用于主域名相同的情况。如果主域名不同，则无法通过此方法解决跨域问题。</li><li>设置 <code>document.domain</code> 可能会影响页面的安全性，因此应谨慎使用，并确保只在受信任的上下文中操作。</li></ul><h2 id="4">四、location.hash + iframe方案</h2><p>使用 <code>location.hash</code> 和 <code>&lt;iframe&gt;</code> 实现跨域通信是一种巧妙的方法，特别适用于需要在不同源的页面之间传递少量数据的情况。这种方法利用了 iframe 的 src 属性和 location 对象的 hash 属性（即 URL 中 “#” 后面的部分），允许父页面和嵌入的 iframe 页面之间进行单向或双向的数据交换。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li><strong>父页面</strong>通过修改 iframe 的 src 属性中的 hash 部分来向 iframe 发送消息。</li><li>**子页面（iframe）**可以通过监听自身的 <code>hashchange</code> 事件来接收来自父页面的消息。</li><li>类似地，<strong>子页面</strong>也可以通过修改父页面的 <code>location.hash</code> 来发送消息给父页面，父页面则监听自身的 <code>hashchange</code> 事件来接收这些消息。</li></ul><h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="父页面向-iframe-发送消息"><a href="#父页面向-iframe-发送消息" class="headerlink" title="父页面向 iframe 发送消息"></a>父页面向 iframe 发送消息</h4><ol><li><p>在父页面中创建一个指向目标域名的 iframe：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://otherdomain.com/page.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 JavaScript 修改 iframe 的 src 属性中的 hash 部分来发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>);</span><br><span class="line">iframe.<span class="property">src</span> = iframe.<span class="property">src</span>.<span class="title function_">split</span>(<span class="string">&#x27;#&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;#&#x27;</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;Hello from parent!&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="iframe-接收消息并处理"><a href="#iframe-接收消息并处理" class="headerlink" title="iframe 接收消息并处理"></a>iframe 接收消息并处理</h4><ol><li>在 iframe 内部监听 <code>hashchange</code> 事件来捕获来自父页面的消息：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">decodeURIComponent</span>(location.<span class="property">hash</span>.<span class="title function_">substr</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message:&#x27;</span>, message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="iframe-向父页面发送消息"><a href="#iframe-向父页面发送消息" class="headerlink" title="iframe 向父页面发送消息"></a>iframe 向父页面发送消息</h4><ol><li><p>在 iframe 内部通过修改父页面的 <code>location.hash</code> 来发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parent.<span class="property">location</span>.<span class="property">hash</span> = <span class="string">&#x27;Message from iframe&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 跨域时会抛出异常，可以忽略或者做其他处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在父页面中监听 <code>hashchange</code> 事件以接收来自 iframe 的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">decodeURIComponent</span>(location.<span class="property">hash</span>.<span class="title function_">substr</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message from iframe:&#x27;</span>, message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用 <code>location.hash</code> 进行跨域通信有一定的局限性，比如只能传输简单的字符串信息，并且长度受限于浏览器对 URL 总长度的限制。</li><li>由于涉及到直接操作 URL，频繁的更改可能会导致用户体验问题，如浏览器历史记录条目的增加。</li></ul><h2 id="5">五、window.name + iframe方案</h2><p>使用 <code>window.name</code> 和 <code>&lt;iframe&gt;</code> 实现跨域通信是一种较为巧妙的方法，利用了浏览器的一个特性：<code>window.name</code> 属性在页面的整个生命周期内保持不变，即使页面的 URL 发生变化，只要没有重新加载或导航到其他页面，<code>window.name</code> 的值就不会改变。这使得它成为一种可行的跨域通信手段。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p><strong>初始设置</strong>：</p><ul><li>在父页面中创建一个指向目标域名的 iframe。</li><li>目标页面（即 iframe 中加载的页面）设置其 <code>window.name</code> 为需要传递的数据。</li></ul></li><li><p><strong>数据传递</strong>：</p><ul><li>父页面通过将 iframe 的 src 更改为与自身同源的一个空白页（例如，父页面所在域下的一个空 HTML 文件），然后访问 iframe 的 <code>contentWindow.name</code> 来读取之前设置的 <code>window.name</code> 值。</li></ul></li><li><p><strong>清理</strong>：</p><ul><li>由于 <code>window.name</code> 可能会被后续操作覆盖或污染，通常会在读取完数据后立即将其重置为空字符串或其他默认值。</li></ul></li></ol><h3 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="目标页面（子页面）"><a href="#目标页面（子页面）" class="headerlink" title="目标页面（子页面）"></a>目标页面（子页面）</h4><ol><li>在目标页面（即要从其获取数据的页面）中设置 <code>window.name</code>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span>&#125;); <span class="comment">// 将需要传递的数据序列化为字符串</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="父页面"><a href="#父页面" class="headerlink" title="父页面"></a>父页面</h4><ol><li><p>创建 iframe 并设置其 src 属性为目标页面的 URL：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://otherdomain.com/page.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 JavaScript 修改 iframe 的 src 属性为与父页面同源的一个空白页，并读取 <code>window.name</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 iframe 加载完成时</span></span><br><span class="line">iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 修改 iframe 的 src 到同源的一个空白页</span></span><br><span class="line">    iframe.<span class="property">src</span> = <span class="string">&quot;about:blank&quot;</span>; <span class="comment">// 或者是一个同源的空白HTML文件URL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 iframe 的 window.name 获取数据</span></span><br><span class="line">    <span class="keyword">var</span> data = iframe.<span class="property">contentWindow</span>.<span class="property">name</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理接收到的数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(data)); <span class="comment">// 解析返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 window.name 防止泄露</span></span><br><span class="line">    iframe.<span class="property">contentWindow</span>.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>这种方法适用于一次性的数据传递，因为一旦页面导航或重新加载，<code>window.name</code> 的值可能会被覆盖或丢失。</li><li><code>window.name</code> 的大小有限制（不同浏览器可能有所不同），因此不适合传输大量数据。</li></ul><h2 id="6">六、postMessage API方案</h2><p><code>postMessage</code> 是一种用于实现安全的跨文档消息传递的API，允许来自不同源的窗口或iframe之间进行通信。它不仅适用于父页面和子iframe之间的通信，也适用于任何两个窗口（如通过 <code>window.open</code> 打开的新窗口）之间的通信。这种方法比使用 <code>location.hash</code>、<code>document.domain</code> 或 <code>window.name</code> 更加灵活和安全。</p><h3 id="使用-postMessage-实现跨域通信"><a href="#使用-postMessage-实现跨域通信" class="headerlink" title="使用 postMessage 实现跨域通信"></a>使用 <code>postMessage</code> 实现跨域通信</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>发送消息的一方使用如下格式调用 <code>postMessage</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.<span class="title function_">postMessage</span>(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li><code>message</code>: 需要传递的数据。可以是任意类型的对象，但如果需要支持旧版浏览器，建议使用基本数据类型或JSON可序列化的对象。</li><li><code>targetOrigin</code>: 指定目标窗口的源（协议+域名+端口），只有当目标窗口的源与此参数匹配时，才会发送消息。使用 <code>&quot;*&quot;</code> 表示不检查源，但这通常不推荐因为存在安全隐患。</li><li><code>[transfer]</code> (可选): 一个数组，包含要转移所有权的对象（例如ArrayBuffer对象）。这些对象在发送后将不再属于发送者。</li></ul><p>接收消息的一方需要监听 <code>message</code> 事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查消息来源是否可信</span></span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://expected-origin.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理接收到的消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要回复，可以使用 event.source.postMessage()</span></span><br><span class="line">    event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Response message&#x27;</span>, event.<span class="property">origin</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="父页面向-iframe-发送消息-1"><a href="#父页面向-iframe-发送消息-1" class="headerlink" title="父页面向 iframe 发送消息"></a>父页面向 iframe 发送消息</h4><p><strong>父页面代码：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://otherdomain.com/page.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 向iframe发送消息</span></span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from parent&#x27;</span>, <span class="string">&#x27;http://otherdomain.com&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>iframe代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听来自父页面的消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 确认消息来源</span></span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://parentdomain.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received from parent:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复消息给父页面</span></span><br><span class="line">    event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello back to parent&#x27;</span>, event.<span class="property">origin</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="iframe-向父页面发送消息-1"><a href="#iframe-向父页面发送消息-1" class="headerlink" title="iframe 向父页面发送消息"></a>iframe 向父页面发送消息</h4><p>只需调整上述示例中的角色，即在 iframe 中使用 <code>parent.postMessage()</code> 发送消息，在父页面中监听 <code>message</code> 事件即可。</p><p><strong>iframe代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向父页面发送消息</span></span><br><span class="line">parent.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from iframe&#x27;</span>, <span class="string">&#x27;http://parentdomain.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>父页面代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听来自iframe的消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://otherdomain.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received from iframe:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>安全性</strong>: 始终验证 <code>event.origin</code> 来确保消息是从预期的来源接收的。不要信任未经验证的消息内容。</li><li><strong>数据类型</strong>: 虽然可以发送复杂对象，但要注意兼容性问题，特别是在处理旧版浏览器时。</li><li><strong>性能</strong>: 对于频繁的消息传递，考虑消息的大小和频率以避免影响性能。</li></ul><h2 id="7">七、CORS跨域方案</h2><p>跨域资源共享（Cross-Origin Resource Sharing，简称 CORS）是一种基于HTTP的协议，它允许服务器声明哪些源可以访问其资源。CORS通过在HTTP响应中添加特定的头部信息来控制跨域请求的行为，从而增强了Web应用的安全性。</p><h3 id="CORS的工作原理"><a href="#CORS的工作原理" class="headerlink" title="CORS的工作原理"></a>CORS的工作原理</h3><p>CORS机制主要依赖于以下几个HTTP头部：</p><ul><li><strong>Origin</strong>: 这个头部由浏览器自动添加到跨域请求中，表明发起请求的来源（协议+域名+端口）。</li><li><strong>Access-Control-Allow-Origin</strong>: 服务器使用这个头部来指定哪些源可以访问资源。它可以设置为具体的源（如<code>http://example.com</code>），也可以设置为通配符<code>*</code>表示允许所有源访问。</li><li><strong>Access-Control-Allow-Methods</strong>: 指定允许的HTTP方法（如GET, POST, PUT等）。</li><li><strong>Access-Control-Allow-Headers</strong>: 指定除了默认的简单请求头外，还允许哪些自定义请求头。</li><li><strong>Access-Control-Allow-Credentials</strong>: 表示是否允许发送凭据（如Cookies、HTTP认证信息）。默认情况下，CORS请求不会发送这些凭据。</li></ul><h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><p>CORS请求分为两种类型：<strong>简单请求</strong>和<strong>预检请求</strong>。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>满足以下条件的请求被认为是简单请求：</p><ul><li>使用<code>GET</code>, <code>HEAD</code>, 或 <code>POST</code> 方法。</li><li>HTTP 头部仅包含<code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code>, <code>Content-Type</code>（但限制为<code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, 或 <code>text/plain</code>）。</li></ul><p>对于简单请求，浏览器直接发送请求，并检查响应中的<code>Access-Control-Allow-Origin</code>头部以确定是否允许该请求。</p><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>如果请求不符合简单请求的标准，浏览器会首先发送一个<code>OPTIONS</code>请求（称为预检请求）来询问服务器是否允许实际请求。预检请求会携带如下头部：</p><ul><li><strong>Access-Control-Request-Method</strong>: 实际请求将使用的HTTP方法。</li><li><strong>Access-Control-Request-Headers</strong>: 实际请求将携带的额外HTTP头部。</li></ul><p>服务器需要响应一个200状态码，并且在响应头部中包含必要的CORS头部信息。</p><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>安全性</strong>: 不要随意设置<code>Access-Control-Allow-Origin</code>为<code>*</code>，尤其是在需要发送凭据的情况下。应该根据实际情况精确控制允许访问的源。</li></ul><h2 id="8">八、WebSocket协议方案</h2><p>WebSocket 协议本身并不受限于同源策略（Same-Origin Policy），这意味着 WebSocket 连接可以在不同的源之间建立，而不需要像传统的 HTTP 请求那样处理跨域资源共享（CORS）。然而，在实际应用中，为了确保安全性，服务器通常会验证请求的来源，并决定是否接受连接。</p><h3 id="WebSocket-跨域的基本原理"><a href="#WebSocket-跨域的基本原理" class="headerlink" title="WebSocket 跨域的基本原理"></a>WebSocket 跨域的基本原理</h3><p>在 WebSocket 连接中，浏览器会在握手阶段发送一个标准的 HTTP 请求，该请求包含以下关键头部：</p><ul><li><strong>Origin</strong>: 浏览器自动添加此头部，指示发起 WebSocket 连接的源（协议+域名+端口）。</li><li><strong>Sec-WebSocket-Key</strong>: 用于握手过程中的安全验证。</li><li><strong>Sec-WebSocket-Version</strong>: 指示使用的 WebSocket 协议版本。</li></ul><p>服务器在收到连接请求后，可以通过检查 <code>Origin</code> 头部来决定是否允许该连接。如果服务器认为该来源是可信的，则可以继续握手并建立连接；否则，服务器可以选择拒绝连接。</p><h3 id="服务器端配置-WebSocket-跨域"><a href="#服务器端配置-WebSocket-跨域" class="headerlink" title="服务器端配置 WebSocket 跨域"></a>服务器端配置 WebSocket 跨域</h3><p>以下是js服务器环境下的 WebSocket 跨域配置示例。</p><h4 id="Node-js-使用-ws-库"><a href="#Node-js-使用-ws-库" class="headerlink" title="Node.js 使用 ws 库"></a>Node.js 使用 <code>ws</code> 库</h4><p>在 Node.js 中使用 <code>ws</code> 库时，可以通过中间件或直接在 WebSocket 服务器上设置来处理跨域请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span> = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123; server &#125;);</span><br><span class="line"></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> <span class="title function_">connection</span>(<span class="params">ws, req</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> origin = req.<span class="property">headers</span>[<span class="string">&#x27;origin&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证 Origin 头部</span></span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">&#x27;http://allowed-origin.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection accepted from trusted origin&#x27;</span>);</span><br><span class="line">        ws.<span class="title function_">send</span>(<span class="string">&#x27;Welcome!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Rejected connection from untrusted origin&#x27;</span>);</span><br><span class="line">        ws.<span class="title function_">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> <span class="title function_">incoming</span>(<span class="params">message</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;received: %s&#x27;</span>, message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket server is listening on port 8080&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在浏览器的同源政策下，浏览器一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容，下面列举一些解决这个的方法</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/tags/js/"/>
    
    <category term="跨域" scheme="https://wilsssssssson.github.io/PersonalPage/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>RN-类的使用</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2025/02/19/RN-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2025/02/19/RN-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2025-02-19T08:47:29.000Z</published>
    <updated>2025-02-19T13:07:22.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Native-状态管理：函数组件-vs-类组件"><a href="#React-Native-状态管理：函数组件-vs-类组件" class="headerlink" title="React Native 状态管理：函数组件 vs 类组件"></a>React Native 状态管理：函数组件 vs 类组件</h1><p>在React Native中，状态（<code>state</code>）的管理可以通过函数组件使用<code>useState</code>和<code>useEffect</code>钩子来实现，也可以通过类组件的传统方式来处理。以下分别展示了这两种方式的具体实现。</p><h2 id="使用函数组件与Hooks"><a href="#使用函数组件与Hooks" class="headerlink" title="使用函数组件与Hooks"></a>使用函数组件与Hooks</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Index</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">  <span class="keyword">const</span> [statusBarColor, setStatusBarColor] = <span class="title function_">useState</span>(<span class="string">&#x27;green&#x27;</span>);  <span class="comment">//react中常用的响应式方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 使用useEffect Hook监听statusBarColor的变化，当其变化时执行回调函数</span></span><br><span class="line">    <span class="title class_">StatusBar</span>.<span class="title function_">setBackgroundColor</span>(statusBarColor);  </span><br><span class="line">  &#125;, [statusBarColor]);<span class="comment">// 只有当statusBarColor改变时才会触发此effect</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">toggleStatusBarColor</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">    <span class="keyword">const</span> newColor = statusBarColor === <span class="string">&#x27;green&#x27;</span> ? <span class="string">&#x27;red&#x27;</span> : <span class="string">&#x27;green&#x27;</span>;  </span><br><span class="line">    <span class="title function_">setStatusBarColor</span>(newColor);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">trackColor</span>=<span class="string">&#123;&#123;</span> <span class="attr">false:</span> &#x27;<span class="attr">gray</span>&#x27;, <span class="attr">true:</span> &#x27;<span class="attr">green</span>&#x27; &#125;&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">thumbColor</span>=<span class="string">&quot;blue&quot;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onValueChange</span>=<span class="string">&#123;toggleStatusBarColor&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;statusBarColor</span>===<span class="string">&#x27;green&#x27;</span>&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>  </span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用类组件"><a href="#使用类组件" class="headerlink" title="使用类组件"></a>使用类组件</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;  </span><br><span class="line">    <span class="variable language_">super</span>(props);  <span class="comment">// 调用父类构造器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;  <span class="comment">// 初始化state对b</span></span><br><span class="line">      <span class="attr">statusBarColor</span>: <span class="string">&#x27;green&#x27;</span>,  <span class="comment">// 状态栏颜色初始为绿色</span></span><br><span class="line">      <span class="attr">switchValue</span>: <span class="literal">true</span>  <span class="comment">// 开关初始值为true（开）</span></span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 组件更新后自动调用，检查状态变化并作出相应操作</span></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (prevState.<span class="property">statusBarColor</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">statusBarColor</span>) &#123;  <span class="comment">// 如果状态栏颜色发生了变化</span></span><br><span class="line">      <span class="title class_">StatusBar</span>.<span class="title function_">setBackgroundColor</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">statusBarColor</span>);  <span class="comment">// 设置状态栏背景颜色</span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 切换状态栏颜色的方法</span></span><br><span class="line">  toggleStatusBarColor = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> newColor = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">statusBarColor</span> === <span class="string">&#x27;green&#x27;</span> ? <span class="string">&#x27;red&#x27;</span> : <span class="string">&#x27;green&#x27;</span>;  <span class="comment">// 切换颜色</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;  <span class="comment">// 更新状态</span></span><br><span class="line">      <span class="attr">statusBarColor</span>: newColor,  </span><br><span class="line">      <span class="attr">switchValue</span>: !<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">switchValue</span>  <span class="comment">// 同步更新switch的状态</span></span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;  <span class="comment">//react的render在每次组件的state和props改变的时候，调用该函数</span></span><br><span class="line">    <span class="keyword">return</span> (  </span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switch</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">trackColor</span>=<span class="string">&#123;&#123;</span> <span class="attr">false:</span> &#x27;<span class="attr">gray</span>&#x27;, <span class="attr">true:</span> &#x27;<span class="attr">green</span>&#x27; &#125;&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">thumbColor</span>=<span class="string">&quot;blue&quot;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onValueChange</span>=<span class="string">&#123;this.toggleStatusBarColor&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;this.state.switchValue&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>  </span><br><span class="line">    );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">React Native 状态管理：函数组件 vs 类组件</summary>
    
    
    
    <category term="RN" scheme="https://wilsssssssson.github.io/PersonalPage/categories/RN/"/>
    
    
    <category term="RN" scheme="https://wilsssssssson.github.io/PersonalPage/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>React-render</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/07/12/React-render/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/07/12/React-render/</id>
    <published>2024-07-12T01:12:36.000Z</published>
    <updated>2025-02-19T12:52:19.843Z</updated>
    
    <content type="html"><![CDATA[<p><code>render()</code> 方法在 React 组件中扮演着核心角色，它定义了组件的 UI 结构，并且决定了组件最终渲染到页面上的样子。以下是 <code>render()</code> 方法的具体作用和一些关键点：</p><h3 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h3><ol><li><p><strong>描述 UI</strong>：<code>render()</code> 方法返回一个 React 元素（可以是一个简单的 DOM 标签、复杂的自定义组件或者它们的组合），这些元素描述了组件的 UI 层次结构。</p></li><li><p><strong>生成虚拟 DOM</strong>：React 使用 JSX 语法（JavaScript 的一种语法扩展）来编写 UI 代码。当组件被渲染时，<code>render()</code> 方法会生成一个虚拟 DOM（Virtual DOM），这是一个轻量级的内存中的 DOM 表示形式。</p></li><li><p><strong>比较与更新</strong>：React 通过对比新旧虚拟 DOM 的差异（这一过程称为“diffing”），然后仅对实际变化的部分进行必要的最小化更新，从而高效地更新真实的 DOM，以保持用户界面的最新状态。</p></li></ol><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><ul><li><p><strong>纯函数性</strong>：理论上，<code>render()</code> 应该是无副作用的，意味着它不应该修改组件的状态或执行其他有副作用的操作。它的唯一目的是基于当前的 props 和 state 返回 UI 描述。</p></li><li><p><strong>响应式更新</strong>：每当组件的 props 或 state 发生变化时，React 会自动调用 <code>render()</code> 方法来重新生成 UI，确保显示的内容始终反映最新的数据状态。</p></li><li><p><strong>生命周期的一部分</strong>：对于类组件来说，<code>render()</code> 是生命周期方法之一。它会在组件实例化后首次加载到页面时以及每次组件更新时被调用。而在函数组件中，这个逻辑隐含在函数体内部，因为整个函数本身就是用来定义渲染输出的。</p></li></ul><h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><p>在你提供的例子中，无论是函数组件还是类组件，<code>render()</code> 都负责定义如何将数据（props 和 state）转化为可视化的 UI 元素。例如，在类组件中，<code>render()</code> 方法返回了一个包含 <code>Switch</code> 组件的 <code>View</code> 组件，根据当前的状态（如 <code>statusBarColor</code> 和 <code>switchValue</code>）决定开关的位置和颜色等属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">trackColor</span>=<span class="string">&#123;&#123;</span> <span class="attr">false:</span> &#x27;<span class="attr">gray</span>&#x27;, <span class="attr">true:</span> &#x27;<span class="attr">green</span>&#x27; &#125;&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">thumbColor</span>=<span class="string">&quot;blue&quot;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onValueChange</span>=<span class="string">&#123;this.toggleStatusBarColor&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;this.state.switchValue&#125;</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>  </span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">render函数的使用及特性</summary>
    
    
    
    <category term="react" scheme="https://wilsssssssson.github.io/PersonalPage/categories/react/"/>
    
    
    <category term="react" scheme="https://wilsssssssson.github.io/PersonalPage/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>RN-连接初始化</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/07/01/RN-%E8%BF%9E%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/07/01/RN-%E8%BF%9E%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2024-07-01T05:20:02.000Z</published>
    <updated>2025-02-19T12:53:08.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MUMU模拟器与Hermes调试"><a href="#MUMU模拟器与Hermes调试" class="headerlink" title="MUMU模拟器与Hermes调试"></a>MUMU模拟器与Hermes调试</h1><h2 id="连接MUMU模拟器"><a href="#连接MUMU模拟器" class="headerlink" title="连接MUMU模拟器"></a>连接MUMU模拟器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect 127.0.0.1:7555</span><br></pre></td></tr></table></figure><h2 id="开发者菜单，用于调试"><a href="#开发者菜单，用于调试" class="headerlink" title="开发者菜单，用于调试"></a>开发者菜单，用于调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 82</span><br></pre></td></tr></table></figure><h2 id="使用Hermes打开控制台或在Node-js中查看输出"><a href="#使用Hermes打开控制台或在Node-js中查看输出" class="headerlink" title="使用Hermes打开控制台或在Node.js中查看输出"></a>使用Hermes打开控制台或在Node.js中查看输出</h2><h3 id="在-Chrome-浏览器中操作"><a href="#在-Chrome-浏览器中操作" class="headerlink" title="在 Chrome 浏览器中操作"></a>在 Chrome 浏览器中操作</h3><ol><li>导航到 <code>chrome://inspect</code>。</li><li>使用 “Configure…” 按钮添加开发服务器地址（通常是 <code>localhost:8081</code>）。</li><li>现在应该能看到一个带有 “inspect” 链接的 “Hermes React Native” 目标。点击这个链接打开调试器。</li></ol><pre><code></code></pre>]]></content>
    
    
    <summary type="html">react native初始化连接</summary>
    
    
    
    <category term="RN" scheme="https://wilsssssssson.github.io/PersonalPage/categories/RN/"/>
    
    
    <category term="RN" scheme="https://wilsssssssson.github.io/PersonalPage/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>Router</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/06/23/Router/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/06/23/Router/</id>
    <published>2024-06-23T06:30:13.000Z</published>
    <updated>2025-02-19T12:53:42.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="路由链接和视图显示"><a href="#路由链接和视图显示" class="headerlink" title="路由链接和视图显示"></a>路由链接和视图显示</h3><h4 id="路由链接"><a href="#路由链接" class="headerlink" title="路由链接 &lt;RouterLink&gt;"></a>路由链接 <code>&lt;RouterLink&gt;</code></h4><p><code>&lt;RouterLink&gt;</code> 用于导航到不同的路由。以下是几种常见的使用方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接指定路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用名称导航 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;xinwen&#x27;&#125;&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用路径对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path: &#x27;/about&#x27;&#125;&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="显示路由加载区域"><a href="#显示路由加载区域" class="headerlink" title="显示路由加载区域 &lt;RouterView&gt;"></a>显示路由加载区域 <code>&lt;RouterView&gt;</code></h4><p><code>&lt;RouterView&gt;</code> 是路由匹配到的组件将要渲染的地方。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterView</span>&gt;</span><span class="tag">&lt;/<span class="name">RouterView</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由配置文件-index-ts"><a href="#路由配置文件-index-ts" class="headerlink" title="路由配置文件 index.ts"></a>路由配置文件 <code>index.ts</code></h3><p>在 <code>index.ts</code> 文件中配置路由规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;./views/News.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Detail</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Detail.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(), <span class="comment">// 路由器的工作模式</span></span><br><span class="line">  <span class="attr">routes</span>: [ <span class="comment">// 路由规则</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="title class_">Detail</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="Query-参数传递"><a href="#Query-参数传递" class="headerlink" title="Query 参数传递"></a>Query 参数传递</h3><p>通过 <code>query</code> 参数进行传参：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    name: &#x27;xiang&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query: &#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">      id: news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">      title: news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">      content: news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">  &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  新闻详情</span><br><span class="line"><span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h4><p><strong>方法1：使用 <code>props</code></strong></p><p>在路由配置中设置 <code>props</code> 函数来接收参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/xiang&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Xiang</span>,</span><br><span class="line">  <span class="title function_">props</span>(<span class="params">route</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> route.<span class="property">query</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件内使用 <code>defineProps</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;content&#x27;</span>]);</span><br></pre></td></tr></table></figure><p><strong>方法2：直接使用 <code>$route</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>编号：&#123;&#123; $route.query.id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>标题：&#123;&#123; $route.query.title &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>内容：&#123;&#123; $route.query.content &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者使用组合式API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123; query &#125; = <span class="title function_">toRefs</span>(route);</span><br><span class="line">    <span class="keyword">return</span> &#123; query &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>可以使用 <code>router.push()</code>、<code>router.replace()</code> 等方法进行编程式导航：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">replace</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: news.<span class="property">id</span>,</span><br><span class="line">    <span class="attr">title</span>: news.<span class="property">title</span>,</span><br><span class="line">    <span class="attr">content</span>: news.<span class="property">content</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>在路由配置中添加重定向规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">vue3中路由的概念以及一些使用方法</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/tags/vue3/"/>
    
    <category term="Router" scheme="https://wilsssssssson.github.io/PersonalPage/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>slot</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/06/13/slot/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/06/13/slot/</id>
    <published>2024-06-13T06:51:02.000Z</published>
    <updated>2025-02-19T12:54:04.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-插槽（Slots）详解"><a href="#Vue-插槽（Slots）详解" class="headerlink" title="Vue 插槽（Slots）详解"></a>Vue 插槽（Slots）详解</h1><h2 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;今日影视推荐&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span> <span class="attr">:src</span>=<span class="string">&quot;videoUrl&quot;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s1&quot;</span>&gt;</span>默认内容1<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s2&quot;</span>&gt;</span>默认内容2<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgUrl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>今日美食城市<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="作用域插槽-父亲决定孩子的样式，但是数据还是儿子自己的"><a href="#作用域插槽-父亲决定孩子的样式，但是数据还是儿子自己的" class="headerlink" title="作用域插槽 (父亲决定孩子的样式，但是数据还是儿子自己的)"></a>作用域插槽 (父亲决定孩子的样式，但是数据还是儿子自己的)</h2><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">:youxi</span>=<span class="string">&quot;games&quot;</span> <span class="attr">x</span>=<span class="string">&quot;哈哈&quot;</span> <span class="attr">y</span>=<span class="string">&quot;你好&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Game</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;params&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- params 可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;y in params.youxi&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;y.id&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123; y.name &#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Game</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:name</span>=<span class="string">&quot;params&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其中 name 是具名插槽的名字，params 是子组件传过来的数据 --&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Vue 插槽（Slots）详解，介绍一些不同的插槽以及基本代码</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/tags/vue3/"/>
    
    <category term="slot" scheme="https://wilsssssssson.github.io/PersonalPage/tags/slot/"/>
    
  </entry>
  
  <entry>
    <title>lazyLoading</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/06/13/lazyLoading/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/06/13/lazyLoading/</id>
    <published>2024-06-13T05:30:51.000Z</published>
    <updated>2025-02-19T12:52:45.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Vue生命周期钩子实现懒加载"><a href="#使用Vue生命周期钩子实现懒加载" class="headerlink" title="使用Vue生命周期钩子实现懒加载"></a>使用Vue生命周期钩子实现懒加载</h1><p>在Vue应用中，可以通过监听<code>scroll</code>事件和利用组件的生命周期钩子来实现数据的懒加载。下面是一个简单的示例，展示了如何实现这一功能。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="language-javascript">export default &#123;  data() &#123;    return &#123;      dataList: [], // 初始数据列表      isLoading: false, // 加载状态      page: 1, // 当前页码    &#125;;  &#125;,  mounted() &#123;    this.loadMoreData();    window.addEventListener(&#39;scroll&#39;, this.handleScroll);  &#125;,  methods: &#123;    loadMoreData() &#123;      this.isLoading = true;      // 模拟数据加载      setTimeout(() =&gt; &#123;        // 假设每次加载5条数据        const newData = Array.from(&#123; length: 5 &#125;, (_, index) =&gt; (&#123;          id: this.dataList.length + index + 1,          content: `数据 $&#123;this.page + index&#125;`,        &#125;));        this.dataList.push(...newData);        this.isLoading = false;        this.page++;      &#125;, 1000); // 利用setTimeout模拟加载数据，实际应替换为HTTP请求    &#125;,    handleScroll() &#123;      // 判断是否滚动到底部      const scrollElement = this.$refs.scrollContainer;      if (        scrollElement.scrollHeight - scrollElement.scrollTop ===        scrollElement.clientHeight      ) &#123;        if (!this.isLoading) &#123;          this.loadMoreData();        &#125;      &#125;    &#125;,  &#125;,  beforeDestroy() &#123;    window.removeEventListener(&#39;scroll&#39;, this.handleScroll);  &#125;,&#125;;</code></pre>]]></content>
    
    
    <summary type="html">在Vue应用中，可以通过监听`scroll`事件和利用组件的生命周期钩子来实现数据的懒加载。下面是一个简单的示例，展示了如何实现这一功能</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/"/>
    
    <category term="Hook" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/Hook/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/tags/vue3/"/>
    
    <category term="Hook" scheme="https://wilsssssssson.github.io/PersonalPage/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>watch监视</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/05/22/watch%E7%9B%91%E8%A7%86/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/05/22/watch%E7%9B%91%E8%A7%86/</id>
    <published>2024-05-22T11:30:39.000Z</published>
    <updated>2025-02-19T12:54:22.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js-Watch-监视器使用详解"><a href="#Vue-js-Watch-监视器使用详解" class="headerlink" title="Vue.js Watch 监视器使用详解"></a>Vue.js Watch 监视器使用详解</h2><h3 id="监视对象类型"><a href="#监视对象类型" class="headerlink" title="监视对象类型"></a>监视对象类型</h3><ul><li><strong>函数</strong>：返回一个值。</li><li><strong>Ref</strong>：监视由 <code>ref</code> 定义的对象类型数据时，实际上是在监视对象的地址值。若要监视对象内部属性的变化，需手动开启深度监视。</li><li><strong>响应式对象</strong>：当监视响应式对象中的某个基本类型的属性时，需要以函数的形式来定义。</li></ul><p>此外，还可以监视由上述类型组成的数组。</p><p><a href="https://cn.vuejs.org/api/reactivity-core.html#watch">Vue.js官方文档</a></p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><code>immediate</code>: 在侦听器创建时立即触发回调。第一次调用时旧值是 <code>undefined</code>。</li><li><code>deep</code>: 如果源是对象，强制深度遍历以便在深层级变更时触发回调。</li><li><code>flush</code>: 调整回调函数的刷新时机，可参考回调的刷新时机及 <code>watchEffect()</code>。</li><li><code>onTrack / onTrigger</code>: 用于调试侦听器的依赖关系。</li><li><code>once</code>: 回调函数只会运行一次，侦听器将在回调函数首次运行后自动停止。</li></ul><blockquote><p>注意：<code>watchEffect</code> 可实现监视页面的所有属性，并且可以实现页面懒加载。</p></blockquote><h3 id="订阅-subscribe-实例"><a href="#订阅-subscribe-实例" class="headerlink" title="订阅 (subscribe) 实例"></a>订阅 (<code>subscribe</code>) 实例</h3><pre><code class="language-javascript">talkStore.$subscribe((mutation, state) =&gt; &#123;    console.log(&#39;talkStore里面保存的数据发生了变化&#39;, mutation, state);    localStorage.setItem(&#39;talkList&#39;, JSON.stringify(state.talkList));&#125;);</code></pre>]]></content>
    
    
    <summary type="html">watch，watchweffect,subscribe的使用方法</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/"/>
    
    <category term="watch" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/watch/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/tags/vue3/"/>
    
    <category term="watch" scheme="https://wilsssssssson.github.io/PersonalPage/tags/watch/"/>
    
  </entry>
  
  <entry>
    <title>asynchronous</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/05/17/asynchronous/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/05/17/asynchronous/</id>
    <published>2024-05-17T07:44:42.000Z</published>
    <updated>2025-02-19T12:54:35.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器多线程与-JavaScript-异步操作"><a href="#浏览器多线程与-JavaScript-异步操作" class="headerlink" title="浏览器多线程与 JavaScript 异步操作"></a>浏览器多线程与 JavaScript 异步操作</h1><h2 id="浏览器多线程"><a href="#浏览器多线程" class="headerlink" title="浏览器多线程"></a>浏览器多线程</h2><p>浏览器通过多个线程来处理不同的任务，以下是主要的线程及其功能：</p><h3 id="主要线程"><a href="#主要线程" class="headerlink" title="主要线程"></a>主要线程</h3><ul><li><strong>GUI 渲染线程</strong>：负责渲染和解析页面内容。</li><li><strong>JS 引擎线程</strong>：负责解析和执行 JavaScript 代码。浏览器只为每个标签页分配一个 JS 引擎线程，因此它是单线程的。</li><li><strong>定时器监听线程</strong>：负责管理 <code>setTimeout</code> 和 <code>setInterval</code> 等定时器操作。</li><li><strong>事件监听线程</strong>：负责监听用户交互事件（如点击、键盘输入等）并触发相应的回调函数。</li><li><strong>HTTP 网络请求线程</strong>：用于处理网络请求。在同一源下，浏览器通常最多分配 5-7 个网络请求线程。</li></ul><h3 id="其他线程"><a href="#其他线程" class="headerlink" title="其他线程"></a>其他线程</h3><p>浏览器还可能有其他线程，例如：</p><ul><li>WebSocket 线程</li><li>文件读取线程</li></ul><h2 id="JavaScript-异步操作"><a href="#JavaScript-异步操作" class="headerlink" title="JavaScript 异步操作"></a>JavaScript 异步操作</h2><p>JavaScript 是单线程语言，但它可以通过异步编程模型实现非阻塞操作。这主要依赖于事件循环机制（Event Loop）以及微任务（Microtasks）和宏任务（Macrotasks）的概念。</p><h3 id="异步微任务"><a href="#异步微任务" class="headerlink" title="异步微任务"></a>异步微任务</h3><p>微任务在当前任务完成后立即执行，优先级较高。常见的微任务包括：</p><ul><li><code>requestAnimationFrame</code></li><li><code>Promise</code></li><li><code>async/await</code></li><li><code>queueMicrotask</code></li><li><code>MutationObserver</code></li><li><code>IntersectionObserver</code></li></ul><h3 id="异步宏任务"><a href="#异步宏任务" class="headerlink" title="异步宏任务"></a>异步宏任务</h3><p>宏任务在每次事件循环的末尾执行，优先级较低。常见的宏任务包括：</p><ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li>事件绑定（如点击事件）</li></ul><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p>JavaScript 中的异步操作是通过浏览器的多线程机制和基于事件循环（Event Loop）的机制来实现的。以下是事件循环的基本流程：</p><ol><li><strong>执行全局脚本</strong>：首先执行全局脚本中的同步代码。</li><li><strong>执行微任务队列</strong>：当全局脚本执行完毕后，会依次执行所有微任务队列中的任务。</li><li><strong>执行宏任务队列</strong>：微任务队列执行完毕后，会从宏任务队列中取出一个任务执行。</li><li><strong>重复步骤 2 和 3</strong>：不断重复执行微任务和宏任务队列中的任务，直到所有任务都完成。</li></ol><img src="/PersonalPage/2024/05/17/asynchronous/image.png" class="" title="This is an example image">]]></content>
    
    
    <summary type="html">js利用浏览器的多线程模拟异步操作</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/tags/js/"/>
    
    <category term="multi-process" scheme="https://wilsssssssson.github.io/PersonalPage/tags/multi-process/"/>
    
  </entry>
  
  <entry>
    <title>Component Communication</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/05/14/Component-Communication/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/05/14/Component-Communication/</id>
    <published>2024-05-14T03:24:11.000Z</published>
    <updated>2025-02-19T12:51:17.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-js-组件之间通信概念详解"><a href="#Vue-js-组件之间通信概念详解" class="headerlink" title="Vue.js 组件之间通信概念详解"></a>Vue.js 组件之间通信概念详解</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>Props</li><li>自定义事件</li><li>mitt（略）</li><li>v-model</li><li>$attrs</li><li>$refs、$parent</li><li>provide、inject</li><li>Pinia</li><li>Slot</li></ol><h2 id="1-Props-父传子数据，子传父"><a href="#1-Props-父传子数据，子传父" class="headerlink" title="1. Props (父传子数据，子传父)"></a>1. Props (父传子数据，子传父)</h2><p>Props用于父组件向子组件传递数据。子组件通过父亲的方法实现数据回传。</p><ul><li><strong>Father Component</strong>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">:car</span>=<span class="string">&quot;car&quot;</span> <span class="attr">:sendToy</span>=<span class="string">&quot;getToy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Children Component</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>([<span class="string">&#x27;car&#x27;</span>,<span class="string">&#x27;sendToy&#x27;</span>])</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-自定义事件-子传父"><a href="#2-自定义事件-子传父" class="headerlink" title="2. 自定义事件 (子传父)"></a>2. 自定义事件 (子传父)</h2><p>通过自定义事件可以将方法从父组件传递给子组件以实现子到父的数据传输。</p><ul><li><strong>Father Component</strong>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">send-toy</span>=<span class="string">&quot;saveToy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Children Component</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;send-toy&#x27;</span>]);</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;emit(&#x27;send-toy&#x27;, toy)&quot;</span>&gt;</span>Send Toy<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-v-model"><a href="#4-v-model" class="headerlink" title="4. v-model"></a>4. v-model</h2><p>v-model用于实现双向数据绑定，可以在HTML标签或组件标签上使用。</p><ul><li><strong>示例</strong>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">v-model:ming</span>=<span class="string">&quot;username&quot;</span> <span class="attr">v-model:mima</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="7-Provide-Inject"><a href="#7-Provide-Inject" class="headerlink" title="7. Provide &amp; Inject"></a>7. Provide &amp; Inject</h2><p>Provide允许祖先组件向其所有后代组件提供数据，而Inject则让后代组件接收这些数据。</p><ul><li><strong>Ancestor Component</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;moneyContext&#x27;</span>, &#123;money, updateMoney&#125;)</span><br></pre></td></tr></table></figure></li><li><strong>Descendant Component</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;money, updateMoney&#125; = <span class="title function_">inject</span>(<span class="string">&#x27;moneyContext&#x27;</span>, &#123;<span class="attr">money</span>:<span class="number">0</span>, <span class="attr">updateMoney</span>:<span class="function">(<span class="params">param:number</span>)=&gt;</span>&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>更多关于Pinia和其他Vue.js核心概念的详细解释将在后续部分中介绍。</p>]]></content>
    
    
    <summary type="html">Vue.js 组件之间通信概念详解</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/"/>
    
    
    <category term="Component Communication" scheme="https://wilsssssssson.github.io/PersonalPage/tags/Component-Communication/"/>
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>lifeCycle</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/05/12/lifeCycle/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/05/12/lifeCycle/</id>
    <published>2024-05-12T05:22:01.000Z</published>
    <updated>2025-02-19T12:52:03.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-生命周期钩子函数使用笔记"><a href="#Vue-生命周期钩子函数使用笔记" class="headerlink" title="Vue 生命周期钩子函数使用笔记"></a>Vue 生命周期钩子函数使用笔记</h1><p>当我们将这些生命周期钩子函数写在自定义Hooks里面时，意味着只要组件引用了这个Hooks，相应的生命周期事件就会自动绑定到该组件上。</p><h2 id="生命周期钩子示例代码"><a href="#生命周期钩子示例代码" class="headerlink" title="生命周期钩子示例代码"></a>生命周期钩子示例代码</h2><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ul><li><p><strong>挂载前</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;挂载前&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载完毕</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子---挂载完毕&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ul><li><p><strong>更新前</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onBeforeUpdate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;更新前&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>更新完毕</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;更新完毕&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><ul><li><p><strong>卸载前</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;卸载前&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>卸载完毕</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;卸载完毕&#x27;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><img src="/PersonalPage/2024/05/12/lifeCycle/image.png" class="" title="This is an example image">]]></content>
    
    
    <summary type="html">生命周期钩子函数使用笔记,主要介绍一些生命周期，以及之间的时间顺序</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/"/>
    
    <category term="Hook" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/Hook/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/tags/vue3/"/>
    
    <category term="lifeCycle" scheme="https://wilsssssssson.github.io/PersonalPage/tags/lifeCycle/"/>
    
    <category term="Hook" scheme="https://wilsssssssson.github.io/PersonalPage/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>javascript-防抖节流</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/05/09/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/05/09/javascript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2024-05-09T03:22:16.000Z</published>
    <updated>2025-02-19T12:50:28.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript中的防抖与节流技术"><a href="#JavaScript中的防抖与节流技术" class="headerlink" title="JavaScript中的防抖与节流技术"></a>JavaScript中的防抖与节流技术</h1><p>在处理频繁触发的事件（如窗口调整大小、滚动、输入框输入等）时，为了提高性能和用户体验，我们通常会使用防抖（Debounce）或节流（Throttle）技术。下面分别介绍这两种技术的实现方法。</p><h2 id="防抖-Debounce"><a href="#防抖-Debounce" class="headerlink" title="防抖 (Debounce)"></a>防抖 (Debounce)</h2><p>防抖的基本思想是：当事件被触发后，延迟指定的时间间隔再执行函数，如果在这个时间间隔内该事件又被触发，则重新计时。</p><h3 id="实现代码示例"><a href="#实现代码示例" class="headerlink" title="实现代码示例"></a>实现代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;fangdou&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberadd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">innerHTML</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给元素绑定mousemove事件，并应用防抖</span></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">debounce</span>(numberadd, <span class="number">500</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 使用箭头函数可以让<code>this</code>上下文自动正确地绑定，因此不需要手动用<code>apply</code>方法来绑定<code>this</code>。</p><h2 id="节流-Throttle"><a href="#节流-Throttle" class="headerlink" title="节流 (Throttle)"></a>节流 (Throttle)</h2><p>节流的核心概念是：保证一个函数在一定时间内只执行一次，即使这个时间段内该函数被多次触发。</p><h3 id="实现代码示例-1"><a href="#实现代码示例-1" class="headerlink" title="实现代码示例"></a>实现代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span>;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">            timer = <span class="literal">null</span>; <span class="comment">// 清空定时器</span></span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在网页端容易出现用户频繁点击导致网页抖动或请求平凡发送，这个文章用settime设置计时器实现防抖即节流</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/tags/js/"/>
    
    <category term="防抖" scheme="https://wilsssssssson.github.io/PersonalPage/tags/%E9%98%B2%E6%8A%96/"/>
    
    <category term="节流" scheme="https://wilsssssssson.github.io/PersonalPage/tags/%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>javascript-promise</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/05/05/javascript-promise/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/05/05/javascript-promise/</id>
    <published>2024-05-05T10:00:38.000Z</published>
    <updated>2025-02-19T12:49:54.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-Promise-状态与方法详解"><a href="#JavaScript-Promise-状态与方法详解" class="headerlink" title="JavaScript Promise 状态与方法详解"></a>JavaScript Promise 状态与方法详解</h1><h2 id="Promise-的三种状态"><a href="#Promise-的三种状态" class="headerlink" title="Promise 的三种状态"></a>Promise 的三种状态</h2><p>Promise 对象有以下三种状态：</p><ul><li><strong>待定（pending）</strong>：初始状态，既没有被兑现，也没有被拒绝。</li><li><strong>已兑现（fulfilled）</strong>：意味着操作成功完成。</li><li><strong>已拒绝（rejected）</strong>：意味着操作失败。</li></ul><img src="/PersonalPage/2024/05/05/javascript-promise/promises.png" class="" title="promise流程"><h2 id="then-方法"><a href="#then-方法" class="headerlink" title=".then() 方法"></a><code>.then()</code> 方法</h2><p><code>.then()</code> 方法用于处理 Promise 的结果。它最多接受两个参数：</p><ol><li>第一个参数是 Promise 兑现时的回调函数。</li><li>第二个参数是 Promise 拒绝时的回调函数。</li></ol><p>每个 <code>.then()</code> 返回一个新的 Promise 对象，可以用于链式调用。</p><h2 id="Promise-并发控制"><a href="#Promise-并发控制" class="headerlink" title="Promise 并发控制"></a>Promise 并发控制</h2><p>Promise 类提供了四个静态方法来促进异步任务的并发：</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><code>Promise.all()</code></h3><p>在所有传入的 Promise 都被兑现时兑现；在任意一个 Promise 被拒绝时拒绝。</p><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a><code>Promise.allSettled()</code></h3><p>在所有的 Promise 都被敲定时兑现，无论它们是被兑现还是被拒绝。</p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><code>Promise.any()</code></h3><p>在任意一个 Promise 被兑现时兑现；仅在所有的 Promise 都被拒绝时才会拒绝。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><code>Promise.race()</code></h3><p>在任意一个 Promise 被敲定时敲定。换句话说，在任意一个 Promise 被兑现或被拒绝时立即返回。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个完整的示例，展示了如何使用 Promise 处理异步操作及其错误处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了尝试错误处理，使用“阈值”值会随机地引发错误。</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">THRESHOLD_A</span> = <span class="number">8</span>; <span class="comment">// 可以使用 0 使错误必现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tetheredGetNumber</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了tetheredGetNumber&#x27;</span>, resolve, reject);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> randomInt = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 当前时间戳</span></span><br><span class="line">        <span class="keyword">const</span> value = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="variable constant_">THRESHOLD_A</span>) &#123; <span class="comment">// 小于8的时间</span></span><br><span class="line">            <span class="title function_">resolve</span>(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">`太大了：<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">determineParity</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了determineParity&#x27;</span>, value);</span><br><span class="line">    <span class="keyword">const</span> isOdd = value % <span class="number">2</span> === <span class="number">1</span>; <span class="comment">// 判断是否为奇数</span></span><br><span class="line">    <span class="keyword">return</span> &#123; value, isOdd &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">troubleWithGetNumber</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了troubleWithGetNumber&#x27;</span>, reason);</span><br><span class="line">    <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;获取数据时遇到问题&quot;</span>, &#123; <span class="attr">cause</span>: reason &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseGetWord</span>(<span class="params">parityInfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了promiseGetWord&#x27;</span>, parityInfo);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, isOdd &#125; = parityInfo;</span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="variable constant_">THRESHOLD_A</span> - <span class="number">1</span>) &#123; <span class="comment">// 7</span></span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">`还是太大了：<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parityInfo.<span class="property">wordEvenOdd</span> = isOdd ? <span class="string">&quot;奇数&quot;</span> : <span class="string">&quot;偶数&quot;</span>;</span><br><span class="line">            <span class="title function_">resolve</span>(parityInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(tetheredGetNumber)</span><br><span class="line">    .<span class="title function_">then</span>(determineParity, troubleWithGetNumber) <span class="comment">// then 接受两个参数，（成功之后执行，失败之后执行）</span></span><br><span class="line">    .<span class="title function_">then</span>(promiseGetWord)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`得到了：<span class="subst">$&#123;info.value&#125;</span>, <span class="subst">$&#123;info.wordEvenOdd&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reason.<span class="property">cause</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;已经在前面处理过错误了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`运行 promiseGetWord() 时遇到问题：<span class="subst">$&#123;reason&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;所有回调都完成了&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><strong><code>tetheredGetNumber</code></strong>：模拟异步操作，使用 <code>setTimeout</code> 模拟延迟，并根据阈值决定是兑现还是拒绝 Promise。</li><li><strong><code>determineParity</code></strong>：检查数字是奇数还是偶数，并返回包含该信息的对象。</li><li><strong><code>troubleWithGetNumber</code></strong>：处理 Promise 被拒绝的情况，抛出一个新的错误。</li><li><strong><code>promiseGetWord</code></strong>：根据阈值决定是否继续兑现 Promise 或拒绝它，并添加额外的信息到对象中。</li><li><strong>链式调用</strong>：通过 <code>.then()</code> 方法处理成功和失败的结果，并最终使用 <code>.catch()</code> 和 <code>.finally()</code> 进行错误处理和清理工作。</li></ol>]]></content>
    
    
    <summary type="html">详解js的promise机制</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/tags/js/"/>
    
    <category term="promise" scheme="https://wilsssssssson.github.io/PersonalPage/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>javascript-json</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/04/01/javascript-json/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/04/01/javascript-json/</id>
    <published>2024-04-01T14:52:19.000Z</published>
    <updated>2025-02-19T12:49:32.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-中的-JSON-处理"><a href="#JavaScript-中的-JSON-处理" class="headerlink" title="JavaScript 中的 JSON 处理"></a>JavaScript 中的 JSON 处理</h1><p>JavaScript 内置了对 JSON 的解析支持，允许轻松地在 JSON 和 JavaScript 对象之间进行转换。</p><h2 id="JSON-数据类型"><a href="#JSON-数据类型" class="headerlink" title="JSON 数据类型"></a>JSON 数据类型</h2><p>JSON 支持的数据类型包括：</p><ul><li><strong>number</strong>：与 JavaScript 的 <code>number</code> 完全一致。</li><li><strong>boolean</strong>：即 JavaScript 的 <code>true</code> 或 <code>false</code>。</li><li><strong>string</strong>：即 JavaScript 的 <code>string</code>。</li><li><strong>null</strong>：即 JavaScript 的 <code>null</code>。</li><li><strong>array</strong>：使用 JavaScript 的数组表示法 <code>[]</code>。</li><li><strong>object</strong>：使用 JavaScript 的对象表示法 <code>&#123; ... &#125;</code>。</li></ul><h2 id="JSON-转换方法"><a href="#JSON-转换方法" class="headerlink" title="JSON 转换方法"></a>JSON 转换方法</h2><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a><code>JSON.stringify</code></h3><p><code>JSON.stringify</code> 方法用于将 JavaScript 对象转换为 JSON 字符串。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value[, replacer [, space]])</span><br></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><strong>value</strong>：要序列化成 JSON 字符串的值。</li><li><strong>replacer</strong>（可选）：<ul><li>如果是函数，则每个属性都会经过该函数的转换和处理。</li><li>如果是数组，则只有包含在这个数组中的属性名才会被序列化。</li><li>如果为 <code>null</code> 或未提供，则对象的所有属性都会被序列化。</li></ul></li><li><strong>space</strong>（可选）：<ul><li>指定缩进用的空白字符串，用于美化输出（pretty-print）。</li><li>如果参数是个数字，它代表有多少的空格；上限为 10。</li><li>如果参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格。</li><li>如果该参数没有提供（或者为 <code>null</code>），将没有空格。</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.65</span>,</span><br><span class="line">    <span class="attr">grade</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;&quot;W3C&quot; Middle School&#x27;</span>,</span><br><span class="line">    <span class="attr">skills</span>: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(xiaoming, <span class="literal">null</span>, <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a><code>JSON.parse</code></h3><p><code>JSON.parse</code> 方法用于将 JSON 字符串转换为 JavaScript 对象。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(text[, reviver])</span><br></pre></td></tr></table></figure><ul><li><strong>text</strong>：要解析的 JSON 字符串。</li><li><strong>reviver</strong>（可选）：一个函数，用来转换解析出的键值对。</li></ul><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>下面是一个从 API 获取天气信息并将其转换为 JSON 格式的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;https://api.openweathermap.org/data/2.5/forecast?q=Xian,cn&amp;appid=800f49846586c3ba6e7052cfc89af16c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> resp.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> info = &#123;</span><br><span class="line">            <span class="attr">city</span>: data.<span class="property">city</span>.<span class="property">name</span>,</span><br><span class="line">            <span class="attr">weather</span>: data.<span class="property">list</span>[<span class="number">0</span>].<span class="property">weather</span>[<span class="number">0</span>].<span class="property">main</span>,</span><br><span class="line">            <span class="attr">time</span>: data.<span class="property">list</span>[<span class="number">0</span>].<span class="property">dt_txt</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(info, <span class="literal">null</span>, <span class="string">&#x27;  &#x27;</span>));</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这段代码通过调用 OpenWeatherMap API 获取西安的天气预报数据，并提取城市名称、当前天气状况和时间信息</p>]]></content>
    
    
    <summary type="html">javascript中的json处理一些方法</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/tags/js/"/>
    
    <category term="JSON" scheme="https://wilsssssssson.github.io/PersonalPage/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>javascript-函数剩余与展开运算符</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/03/28/javascript-%E5%87%BD%E6%95%B0%E5%89%A9%E4%BD%99%E4%B8%8E%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/03/28/javascript-%E5%87%BD%E6%95%B0%E5%89%A9%E4%BD%99%E4%B8%8E%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2024-03-28T01:05:23.000Z</published>
    <updated>2025-02-19T12:49:04.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数剩余参数和展开运算符"><a href="#函数剩余参数和展开运算符" class="headerlink" title="函数剩余参数和展开运算符"></a>函数剩余参数和展开运算符</h1><h2 id="1-动态传参"><a href="#1-动态传参" class="headerlink" title="1. 动态传参"></a>1. 动态传参</h2><p>在JavaScript中，函数可以通过<code>arguments</code>对象来接收动态数量的参数。这是一个类数组对象，包含传递给函数的所有参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 可以传入任意数量的参数</span></span><br><span class="line"><span class="comment">// `arguments` 对象包含了传入的所有参数，但它是伪数组类型</span></span><br></pre></td></tr></table></figure><h2 id="2-剩余运算符（Rest-Operator）"><a href="#2-剩余运算符（Rest-Operator）" class="headerlink" title="2. 剩余运算符（Rest Operator）"></a>2. 剩余运算符（Rest Operator）</h2><p>剩余运算符允许我们将一个不定数量的参数表示为一个数组。它使用三个点<code>...</code>前缀，并且必须是函数的最后一个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">a, b, ...arr</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出除a和b外的所有参数作为一个真数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// arr 将输出 [3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>注意：与<code>arguments</code>不同，通过剩余运算符得到的<code>arr</code>是一个真正的数组，可以直接使用数组的方法。</p><h2 id="3-展开运算符（Spread-Operator）"><a href="#3-展开运算符（Spread-Operator）" class="headerlink" title="3. 展开运算符（Spread Operator）"></a>3. 展开运算符（Spread Operator）</h2><p>展开运算符也使用三个点<code>...</code>，但它用于在调用函数或构建数组时展开数组（或其他可迭代对象）。</p><h3 id="典型应用示例："><a href="#典型应用示例：" class="headerlink" title="典型应用示例："></a>典型应用示例：</h3><ul><li><p><strong>求最大最小值</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...numbers)); <span class="comment">// 使用展开运算符展开数组，找到最大值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>合并数组</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> combinedArr = [...arr1, ...arr2]; <span class="comment">// 合并两个数组，不修改原数组</span></span><br></pre></td></tr></table></figure></li></ul><p>展开运算符不会修改原来的数组，而是创建一个新的数组。</p>]]></content>
    
    
    <summary type="html">函数传参中经常经常用到的不定参数，接受方法，剩余参数和展开运算符</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/tags/js/"/>
    
    <category term="传参" scheme="https://wilsssssssson.github.io/PersonalPage/tags/%E4%BC%A0%E5%8F%82/"/>
    
  </entry>
  
  <entry>
    <title>javascript-常用静态方法</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/03/24/javascript-%E5%B8%B8%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/03/24/javascript-%E5%B8%B8%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</id>
    <published>2024-03-24T08:10:35.000Z</published>
    <updated>2025-02-19T12:48:42.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript常用静态方法"><a href="#JavaScript常用静态方法" class="headerlink" title="JavaScript常用静态方法"></a>JavaScript常用静态方法</h1><p>JavaScript提供了多种方法来操作对象和数组，下面是一些常用的方法及其使用示例。</p><h2 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h2><h3 id="1-Object-keys-获取所有属性名"><a href="#1-Object-keys-获取所有属性名" class="headerlink" title="1. Object.keys - 获取所有属性名"></a>1. <code>Object.keys</code> - 获取所有属性名</h3><p><code>Object.keys</code> 方法返回一个给定对象自身可枚举属性的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(person)); <span class="comment">// 输出: [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="2-Object-values-获取所有属性值"><a href="#2-Object-values-获取所有属性值" class="headerlink" title="2. Object.values - 获取所有属性值"></a>2. <code>Object.values</code> - 获取所有属性值</h3><p><code>Object.values</code> 方法返回一个给定对象自身可枚举属性值的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(person)); <span class="comment">// 输出: [&#x27;Alice&#x27;, 25]</span></span><br></pre></td></tr></table></figure><h3 id="3-拷贝对象并添加属性"><a href="#3-拷贝对象并添加属性" class="headerlink" title="3. 拷贝对象并添加属性"></a>3. 拷贝对象并添加属性</h3><p><code>Object.assign</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source);</span><br><span class="line">target.<span class="property">address</span> = <span class="string">&#x27;Wonderland&#x27;</span>; <span class="comment">// 添加新属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target); <span class="comment">// 输出: &#123; name: &#x27;Alice&#x27;, age: 25, address: &#x27;Wonderland&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="1-forEach-遍历数组"><a href="#1-forEach-遍历数组" class="headerlink" title="1. forEach - 遍历数组"></a>1. <code>forEach</code> - 遍历数组</h3><p><code>forEach</code> 方法允许你遍历数组中的每个元素，并对它们执行一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>偷偷卷！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！<br>此代码会依次输出数组中的每个数字。</p><h3 id="2-filter-过滤数组"><a href="#2-filter-过滤数组" class="headerlink" title="2. filter - 过滤数组"></a>2. <code>filter</code> - 过滤数组</h3><p><code>filter</code> 方法用于创建一个新数组，包含通过所提供函数实现的测试的所有元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> evenNumbers = numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">number</span> =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evenNumbers); <span class="comment">// 输出: [2, 4]</span></span><br></pre></td></tr></table></figure><p>这段代码筛选出所有偶数并存储在<code>evenNumbers</code>中。</p><h3 id="3-map-迭代数组"><a href="#3-map-迭代数组" class="headerlink" title="3. map - 迭代数组"></a>3. <code>map</code> - 迭代数组</h3><p><code>map</code> 方法创建一个新数组，其结果是对调用数组中的每一个元素调用一个提供的函数后的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> squaredNumbers = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">number</span> =&gt;</span> number * number);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(squaredNumbers); <span class="comment">// 输出: [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><p>这会生成一个新的数组，其中每个元素都是原数组对应位置元素的平方。</p><h3 id="4-reduce-累计器"><a href="#4-reduce-累计器" class="headerlink" title="4. reduce - 累计器"></a>4. <code>reduce</code> - 累计器</h3><p><code>reduce</code> 方法对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 输出: 15</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>reduce</code> 将数组中的所有数值相加，从起始值<code>0</code>开始累加。</p><img src="/PersonalPage/2024/03/24/javascript-%E5%B8%B8%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/image1.png" class="" title="有趣的例子"><img src="/PersonalPage/2024/03/24/javascript-%E5%B8%B8%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/image2.png" class="" title="有趣的例子">]]></content>
    
    
    <summary type="html">javascript常用的一些静态方法，一般用于来处理数组，迭代遍历等操作</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/tags/js/"/>
    
    <category term="静态方法" scheme="https://wilsssssssson.github.io/PersonalPage/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>javascript-变量提升</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/03/16/javascript-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/03/16/javascript-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</id>
    <published>2024-03-16T09:13:23.000Z</published>
    <updated>2025-02-19T12:48:22.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-中的变量提升与函数声明提升"><a href="#JavaScript-中的变量提升与函数声明提升" class="headerlink" title="JavaScript 中的变量提升与函数声明提升"></a>JavaScript 中的变量提升与函数声明提升</h1><h2 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h2><p>在 JavaScript 中，使用 <code>var</code> 声明的变量会被提升到其所在作用域的最前面，但赋值操作不会被提升。这意味着可以在声明之前访问这些变量，但它们的值会是 <code>undefined</code>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);  <span class="comment">// 输出: undefined</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上相当于：</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);  <span class="comment">// 输出: undefined</span></span><br><span class="line">num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li><strong>变量声明</strong>：<code>var</code> 声明的变量会被提升到当前作用域的顶部。</li><li><strong>变量赋值</strong>：赋值操作不会被提升，因此在声明之前访问变量时，其值为 <code>undefined</code>。</li></ul><h2 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h2><p>函数声明也会被提升到其所在作用域的最前面，这意味着你可以在函数声明之前调用该函数。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上相当于：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure><h3 id="函数表达式与函数声明的区别"><a href="#函数表达式与函数声明的区别" class="headerlink" title="函数表达式与函数声明的区别"></a>函数表达式与函数声明的区别</h3><p>函数表达式不会像函数声明那样被提升。如果你使用 <code>var</code> 来声明一个函数表达式，并在声明之前调用它，会导致错误或输出 <code>undefined</code>。</p><h4 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 输出: Uncaught TypeError: a is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上相当于：</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 输出: Uncaught TypeError: a is not a function</span></span><br><span class="line">a = <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>为了避免由于变量提升带来的潜在问题，建议不要使用 <code>var</code>，而是使用更现代的 <code>let</code> 和 <code>const</code> 关键字来声明变量。它们具有块级作用域，且不会导致类似的问题。</p><h3 id="使用-let-和-const"><a href="#使用-let-和-const" class="headerlink" title="使用 let 和 const"></a>使用 <code>let</code> 和 <code>const</code></h3><ul><li><strong><code>let</code></strong>：用于声明可以重新赋值的变量，具有块级作用域。</li><li><strong><code>const</code></strong>：用于声明不可重新赋值的常量，也具有块级作用域。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);  <span class="comment">// 输出: ReferenceError: Cannot access &#x27;num&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式同样适用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 输出: ReferenceError: Cannot access &#x27;add&#x27; before initialization</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">通过使用 <span class="string">`let`</span> 和 <span class="string">`const`</span>，可以避免许多由于变量提升引起的问题，并编写更清晰、更安全的代码。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">var的变量函数提升机制</summary>
    
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/categories/js/"/>
    
    
    <category term="js" scheme="https://wilsssssssson.github.io/PersonalPage/tags/js/"/>
    
    <category term="javascript-变量提升" scheme="https://wilsssssssson.github.io/PersonalPage/tags/javascript-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>computed</title>
    <link href="https://wilsssssssson.github.io/PersonalPage/2024/03/12/computed/"/>
    <id>https://wilsssssssson.github.io/PersonalPage/2024/03/12/computed/</id>
    <published>2024-03-12T08:45:54.000Z</published>
    <updated>2025-02-19T12:51:35.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js-计算属性-computed-使用详解"><a href="#Vue-js-计算属性-computed-使用详解" class="headerlink" title="Vue.js 计算属性 (computed) 使用详解"></a>Vue.js 计算属性 (<code>computed</code>) 使用详解</h2><h3 id="计算属性简介"><a href="#计算属性简介" class="headerlink" title="计算属性简介"></a>计算属性简介</h3><p>计算属性 (<code>computed</code>) 在 Vue.js 中通常用于基于其他响应式数据派生出新的值。默认情况下，计算属性是只读的，即它们只有 <code>get</code> 方法而没有 <code>set</code> 方法。然而，通过定义一个带有 <code>get</code> 和 <code>set</code> 方法的对象，可以使计算属性变得可读写。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面的例子展示了如何使用 <code>ref</code> 创建两个响应式变量 <code>firstName</code> 和 <code>lastName</code>，并创建一个可读写的计算属性 <code>fullName</code>。</p><pre><code class="language-javascript">let firstName = ref(&#39;zhang&#39;);let lastName = ref(&#39;san&#39;);// 定义一个可读写的计算属性 fullNamelet fullName = computed(&#123;  // 当 fullName 被读取时调用 get 方法  get() &#123;    return firstName.value.slice(0,1).toUpperCase() + firstName.value.slice(1) + &#39;-&#39; + lastName.value;  &#125;,  // 当 fullName 被修改时调用 set 方法，并接收新值  set(val) &#123;    const [str1, str2] = val.split(&#39;-&#39;);    firstName.value = str1;    lastName.value = str2;  &#125;&#125;);// 修改 fullName 的函数function changeFullName() &#123;  fullName.value = &#39;li-si&#39;;&#125;</code></pre>]]></content>
    
    
    <summary type="html">计算属性的使用方法</summary>
    
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://wilsssssssson.github.io/PersonalPage/tags/vue3/"/>
    
    <category term="computed" scheme="https://wilsssssssson.github.io/PersonalPage/tags/computed/"/>
    
  </entry>
  
</feed>
